name: Build CMD2 packages for Android (Parallel Final)
on:
  watch:
    types: [started]
  workflow_dispatch:
    inputs:
      packages:
        description: '需要构建的软件包（用空格分隔，例如：aria2 samba）'
        required: true
        default: 'aria2 bash curl wget git openssh vim zip unzip tar gzip'  # 默认10个包（2组）

jobs:
  # 任务1：智能拆分包列表，生成带索引的分组（无分组数量限制）
  split-packages:
    name: Split packages into groups (5 per group)
    runs-on: ubuntu-22.04
    outputs:
      package-groups: ${{ steps.split.outputs.groups }}  # 输出：[{index:1, packages:"a b"}, {index:2, packages:"c d"}]
      build-time: ${{ steps.set-time.outputs.build-time }}  # 统一时间戳，供全流程使用
    steps:
      - name: Set global build time (统一全流程时间戳)
        id: set-time
        run: |
          BUILD_TIME=$(TZ=Asia/Shanghai date "+%Y%m%d%H%M")
          echo "build-time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "Global build time set to: $BUILD_TIME"

      - name: Split packages into indexed groups
        id: split
        run: |
          # 1. 解析输入包列表为数组（去重、去空）
          INPUT_PACKAGES="${{ github.event.inputs.packages }}"
          PACKAGE_ARRAY=($(echo "$INPUT_PACKAGES" | tr -s ' ' '\n' | sort -u | grep -v '^$'))
          TOTAL=${#PACKAGE_ARRAY[@]}

          # 容错：若无有效包，直接报错终止
          if [ $TOTAL -eq 0 ]; then
            echo "ERROR: No valid packages input!"
            exit 1
          fi
          echo "Total valid packages: $TOTAL"

          # 2. 每5个包分1组，生成带索引的JSON数组（支持任意分组数量）
          GROUPS_JSON="["
          for ((i=0; i<TOTAL; i+=5)); do
            # 计算当前组索引（1开始）
            GROUP_INDEX=$((i/5 + 1))
            # 截取当前组的包（i到i+4）
            GROUP_PACKAGES=("${PACKAGE_ARRAY[@]:i:5}")
            GROUP_PACKAGES_STR=$(printf "%s " "${GROUP_PACKAGES[@]}" | sed 's/ $//')  # 转为空格分隔字符串

            # 拼接JSON对象（处理最后一组的逗号）
            if [ $i -eq 0 ]; then
              GROUPS_JSON+="{\"index\":$GROUP_INDEX,\"packages\":\"$GROUP_PACKAGES_STR\"}"
            else
              GROUPS_JSON+=",{\"index\":$GROUP_INDEX,\"packages\":\"$GROUP_PACKAGES_STR\"}"
            fi
          done
          GROUPS_JSON+="]"

          # 输出JSON（需转义特殊字符，确保matrix正常解析）
          echo "groups=$GROUPS_JSON" >> $GITHUB_OUTPUT
          echo "Generated package groups: $GROUPS_JSON"


  # 任务2：基于分组矩阵并发编译（每组独立虚拟机，互不干扰）
  build-parallel:
    name: Build Group ${{ matrix.group.index }} (${{ matrix.group.packages }})
    needs: split-packages  # 依赖分组结果和统一时间戳
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false  # 某组失败不影响其他组（容错性提升）
      matrix:
        group: ${{ fromJSON(needs.split-packages.outputs.package-groups) }}  # 动态读取分组
    steps:
      - name: Checkout repository code
        uses: actions/checkout@v4

      - name: Initialize environment (统一变量)
        run: |
          # 引用全局时间戳（与分组、汇总保持一致）
          echo "BUILD_TIME=${{ needs.split-packages.outputs.build-time }}" >> $GITHUB_ENV
          # 分组专属ID（避免跨组文件冲突）
          echo "GROUP_ID=group-${{ matrix.group.index }}" >> $GITHUB_ENV
          # 创建分层目录（构建目录+分组产物目录）
          mkdir -p "${{ github.workspace }}/kernel_workspace"
          mkdir -p "${{ github.workspace }}/build-output/$GROUP_ID"
          echo "Group ID: $GROUP_ID | Build time: $BUILD_TIME"

      - name: Set 10GB swap (root partition, avoid space error)
        uses: pierotofy/set-swap-space@master
        with:
          swap-size-gb: 10
          swap-file-path: "/swapfile"  # 根分区≥25GB，确保空间充足

      - name: Install build dependencies
        run: |
          sudo apt update -y
          # 补充libc6-dev（部分编译依赖），保留原必需工具
          sudo apt install -y tk-dev git xz-utils patch libc6-dev
          sudo systemctl start docker
          # 验证docker服务（避免后续脚本失败）
          if ! sudo docker info >/dev/null 2>&1; then
            echo "ERROR: Docker service failed to start!"
            exit 1
          fi

      - name: Build packages for current group
        run: |
          cd "${{ github.workspace }}"
          echo -e "\n===== Group ${{ matrix.group.index }} Build Start ====="
          echo "Packages: ${{ matrix.group.packages }}"

          # 1. 修复docker版本脚本（原逻辑保留，增加容错）
          DOCKER_BUILD_SH="./root-packages/docker/build.sh"
          if [ -f "$DOCKER_BUILD_SH" ]; then
            sed -i 's/TERMUX_PKG_VERSION=1:/TERMUX_PKG_VERSION=/' "$DOCKER_BUILD_SH"
            sed -i 's/${TERMUX_PKG_VERSION:2}/${TERMUX_PKG_VERSION}/g' "$DOCKER_BUILD_SH"
          else
            echo "WARNING: Docker build script not found, skipping fix..."
          fi

          # 2. 应用补丁（不存在则跳过，不终止流程）
          PATCH_FILE="./test/cmd.patch"
          if [ -f "$PATCH_FILE" ]; then
            if patch -p1 < "$PATCH_FILE"; then
              echo "Patch applied successfully"
            else
              echo "WARNING: Patch failed, continue building..."
            fi
          else
            echo "WARNING: cmd.patch not found, skipping patch..."
          fi

          # 3. 编译DEB包（输出到当前组目录）
          if ./scripts/run-docker.sh ./build-package.sh -i --format debian ${{ matrix.group.packages }}; then
            cd output
            # 复制DEB包到分组目录（仅保留.deb，过滤其他临时文件）
            find . -maxdepth 1 -type f -name "*.deb" -exec cp {} "${{ github.workspace }}/build-output/$GROUP_ID/" \;
            echo "Group ${{ matrix.group.index }} DEB build success: $(ls -1 "${{ github.workspace }}/build-output/$GROUP_ID/"*.deb 2>/dev/null | wc -l) files"
          else
            echo "ERROR: Group ${{ matrix.group.index }} DEB build failed!"
            exit 1  # DEB编译为核心步骤，失败则终止当前组
          fi

          # 4. 构建Magisk模块（非核心步骤，失败不终止）
          REPACK_SCRIPT="./test/cmd/tmp/repack.sh"
          if [ -f "$REPACK_SCRIPT" ]; then
            cp "$REPACK_SCRIPT" ./output
            cd output
            chmod +x repack.sh
            if bash repack.sh; then
              # 合并Magisk产物到分组目录（system目录+cmd.tar.xz）
              cp ./A/data/cmd.tar.xz "${{ github.workspace }}/build-output/$GROUP_ID/" 2>/dev/null
              cp -R ./A/system "${{ github.workspace }}/build-output/$GROUP_ID/" 2>/dev/null
              echo "Group ${{ matrix.group.index }} Magisk build success"
            else
              echo "WARNING: Group ${{ matrix.group.index }} Magisk build failed, skipping..."
            fi
            # 清理Magisk临时文件
            rm -rf ./A repack.sh
          else
            echo "WARNING: repack.sh not found, skipping Magisk build..."
          fi

          echo -e "===== Group ${{ matrix.group.index }} Build End =====\n"

      - name: Upload intermediate group artifacts (temp)
        uses: actions/upload-artifact@v4
        with:
          name: "intermediate-${{ env.GROUP_ID }}-${{ env.BUILD_TIME }}"
          path: "${{ github.workspace }}/build-output/$GROUP_ID/*"
          retention-days: 1  # 临时产物，汇总后自动清理


  # 任务3：汇总所有分组产物，按类型统一打包上传
  aggregate-artifacts:
    name: Aggregate & Upload Final Artifacts
    needs: build-parallel  # 等待所有分组编译完成
    runs-on: ubuntu-22.04
    steps:
      - name: Prepare final directories & variables
        run: |
          # 引用全局时间戳（与分组编译完全一致）
          echo "BUILD_TIME=${{ needs.split-packages.outputs.build-time }}" >> $GITHUB_ENV
          # 创建最终产物目录（按类型分类，清晰易管理）
          mkdir -p "${{ github.workspace }}/final-output/deb"
          mkdir -p "${{ github.workspace }}/final-output/magisk"
          echo "Final aggregation start (build time: $BUILD_TIME)"

      - name: Download all intermediate group artifacts
        uses: actions/download-artifact@v4
        with:
          path: "${{ github.workspace }}/intermediate-artifacts"
          # 精确匹配当前构建的临时产物（避免下载历史产物）
          pattern: "intermediate-group-*-${{ env.BUILD_TIME }}"
          merge-multiple: false  # 保留分组目录结构，防止文件重名覆盖

      - name: Aggregate Debian packages (统一压缩)
        run: |
          echo -e "\n===== Aggregating Debian Packages ====="
          # 收集所有分组的DEB包（去重，避免重复构建的包冲突）
          find "${{ github.workspace }}/intermediate-artifacts" -type f -name "*.deb" | sort -u | while read -r deb_file; do
            cp "$deb_file" "${{ github.workspace }}/final-output/deb/"
          done

          # 统计并压缩（高压缩率，减少上传体积）
          DEB_COUNT=$(ls -1 "${{ github.workspace }}/final-output/deb/"*.deb 2>/dev/null | wc -l)
          if [ $DEB_COUNT -eq 0 ]; then
            echo "ERROR: No Debian packages found across all groups!"
            exit 1
          fi
          echo "Total Debian packages aggregated: $DEB_COUNT"

          cd "${{ github.workspace }}/final-output"
          XZ_OPT="-9" tar -cJf "all-debs-${{ env.BUILD_TIME }}.tar.xz" ./deb/*.deb
          echo "Debian package archive created: all-debs-${{ env.BUILD_TIME }}.tar.xz"

      - name: Aggregate Magisk modules (合并目录+压缩)
        run: |
          echo -e "\n===== Aggregating Magisk Modules ====="
          MAGISK_DIR="${{ github.workspace }}/final-output/magisk"

          # 1. 合并system目录（覆盖式合并，保留所有分组的文件）
          find "${{ github.workspace }}/intermediate-artifacts" -type d -name "system" | while read -r sys_dir; do
            cp -Rf "$sys_dir"/* "$MAGISK_DIR/"  # -f覆盖同名文件，-R递归复制
          done

          # 2. 处理cmd.tar.xz（若多组存在，保留最后一个，避免覆盖丢失）
          find "${{ github.workspace }}/intermediate-artifacts" -type f -name "cmd.tar.xz" | sort | while read -r tar_file; do
            cp -f "$tar_file" "$MAGISK_DIR/"  # 最后一个分组的tar覆盖前序，确保最新
          done

          # 统计并压缩（无Magisk产物则警告，不终止流程）
          if [ -d "$MAGISK_DIR/system" ] || [ -f "$MAGISK_DIR/cmd.tar.xz" ]; then
            cd "$MAGISK_DIR/.."
            XZ_OPT="-9" tar -cJf "all-magisk-${{ env.BUILD_TIME }}.tar.xz" ./magisk/*
            echo "Magisk module archive created: all-magisk-${{ env.BUILD_TIME }}.tar.xz"
          else
            echo "WARNING: No Magisk artifacts found across all groups (skip Magisk upload)"
            touch "$MAGISK_DIR/no-magisk-artifact.txt"  # 标记空产物，避免后续上传报错
          fi

      - name: Upload final Debian package archive
        uses: actions/upload-artifact@v4
        with:
          name: "debian-packages-all-${{ env.BUILD_TIME }}"
          path: "${{ github.workspace }}/final-output/all-debs-${{ env.BUILD_TIME }}.tar.xz"
          retention-days: 3  # 最终产物保留3天

      # 【核心修复】修正 exists() 函数的路径拼接语法
      - name: Upload final Magisk module archive (if exists)
        uses: actions/upload-artifact@v4
        if: ${{ !exists('${{ github.workspace }}/final-output/magisk/no-magisk-artifact.txt') }}
        with:
          name: "magisk-module-all-${{ env.BUILD_TIME }}"
          path: "${{ github.workspace }}/final-output/all-magisk-${{ env.BUILD_TIME }}.tar.xz"
          retention-days: 3
